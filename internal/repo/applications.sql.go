// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: applications.sql

package repo

import (
	"context"
	"time"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (job_id, user_id, status, notes, next_action_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, job_id, user_id, status, notes, next_action_at, created_at, updated_at
`

type CreateApplicationParams struct {
	JobID        int64      `json:"job_id"`
	UserID       int64      `json:"user_id"`
	Status       *string    `json:"status"`
	Notes        *string    `json:"notes"`
	NextActionAt *time.Time `json:"next_action_at"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.JobID,
		arg.UserID,
		arg.Status,
		arg.Notes,
		arg.NextActionAt,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.UserID,
		&i.Status,
		&i.Notes,
		&i.NextActionAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listApplicationsByUser = `-- name: ListApplicationsByUser :many
SELECT id, job_id, user_id, status, notes, next_action_at, created_at, updated_at
FROM applications
WHERE user_id = $1
  AND ($2::text IS NULL OR status = $2)
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

// @Summary      List my applications
// @Description  Kullanıcının kendi başvurularını listeler
// @Tags         applications
// @Security     BearerAuth
// @Accept       json
// @Produce      json
// @Param        status  query     string  false  "applied|interview|offer|denied"
// @Param        limit   query     int     false  "limit (1-100)"
// @Param        offset  query     int     false  "offset"
// @Success      200     {object}  map[string]any
// @Failure      401     {object}  map[string]string
// @Router       /v1/applications [get]

type ListApplicationsByUserParams struct {
	UserID int64   `json:"user_id"`
	Status *string `json:"status"`
	Offset int32   `json:"offset"`
	Limit  int32   `json:"limit"`
}

func (q *Queries) ListApplicationsByUser(ctx context.Context, arg ListApplicationsByUserParams) ([]Application, error) {
	rows, err := q.db.Query(ctx, listApplicationsByUser,
		arg.UserID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.UserID,
			&i.Status,
			&i.Notes,
			&i.NextActionAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplicationStatus = `-- name: UpdateApplicationStatus :one
UPDATE applications
SET status = $1, updated_at = now()
WHERE id = $2 AND user_id = $3
RETURNING id, job_id, user_id, status, notes, next_action_at, created_at, updated_at
`

type UpdateApplicationStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) UpdateApplicationStatus(ctx context.Context, arg UpdateApplicationStatusParams) (Application, error) {
	row := q.db.QueryRow(ctx, updateApplicationStatus, arg.Status, arg.ID, arg.UserID)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.UserID,
		&i.Status,
		&i.Notes,
		&i.NextActionAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
